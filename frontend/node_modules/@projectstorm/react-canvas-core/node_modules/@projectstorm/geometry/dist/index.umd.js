!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports["@projectstorm/react-diagrams-geometry"]=e():t["@projectstorm/react-diagrams-geometry"]=e()}(self,(()=>(()=>{"use strict";var t={n:e=>{var r=e&&e.__esModule?()=>e.default:()=>e;return t.d(r,{a:r}),r},d:(e,r)=>{for(var i in r)t.o(r,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:r[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{BezierCurve:()=>x,BezierCurvepPoints:()=>m,BoundsCorner:()=>h,Matrix:()=>r,Point:()=>i,Polygon:()=>O,Rectangle:()=>d,boundingBoxFromPoints:()=>c,boundingBoxFromPolygons:()=>p,boundsFromPositionAndSize:()=>l,createEmptyBounds:()=>g});class r{constructor(t){this.matrix=t}mmul(t){return this.matrix=this.matrix.map(((e,r)=>t.asArray()[0].map(((i,o)=>e.reduce(((e,i,s)=>e+this.matrix[r][s]*t.asArray()[s][o]),0))))),this}asArray(){return this.matrix}get(t,e){return this.asArray()[t][e]}static multiply(...t){let e=t[0];for(let r=1;r<t.length;r++)e=e.mmul(t[r]);return e}static scaleMatrix(t,e){return new r([[t,0,0],[0,e,0],[0,0,1]])}static translateMatrix(t,e){return new r([[1,0,t],[0,1,e],[0,0,1]])}static rotateMatrix(t){return new r([[Math.cos(t),-1*Math.sin(t),0],[Math.sin(t),Math.cos(t),0],[0,0,1]])}static createScaleMatrix(t,e,i){return this.multiply(r.translateMatrix(i.x,i.y),r.scaleMatrix(t,e),r.translateMatrix(-i.x,-i.y))}static createRotateMatrix(t,e){return this.multiply(r.translateMatrix(e.x,e.y),r.rotateMatrix(t),r.translateMatrix(-e.x,-e.y))}}class i{constructor(t=0,e=0){this.x=t,this.y=e}translate(t,e){this.x+=t,this.y+=e}clone(){return new i(this.x,this.y)}toSVG(){return this.x+" "+this.y}asMatrix(){return new r([[this.x],[this.y],[1]])}transform(t){let e=t.mmul(this.asMatrix());this.x=e.get(0,0),this.y=e.get(1,0)}static middlePoint(t,e){return new i((e.x+t.x)/2,(e.y+t.y)/2)}}const o=require("lodash/forEach");var s=t.n(o);const n=require("lodash/map");var a=t.n(n);const T=require("lodash/flatMap");var h,u=t.n(T);!function(t){t.TOP_LEFT="TL",t.TOP_RIGHT="TR",t.BOTTOM_RIGHT="BR",t.BOTTOM_LEFT="BL"}(h||(h={}));const l=(t,e,r,o)=>({[h.TOP_LEFT]:new i(t,e),[h.TOP_RIGHT]:new i(t+r,e),[h.BOTTOM_RIGHT]:new i(t+r,e+o),[h.BOTTOM_LEFT]:new i(t,e+o)}),g=()=>({[h.TOP_LEFT]:new i,[h.TOP_RIGHT]:new i,[h.BOTTOM_RIGHT]:new i,[h.BOTTOM_LEFT]:new i}),c=t=>{if(0===t.length)return g();let e=t[0].x,r=t[0].x,o=t[0].y,s=t[0].y;for(let i=1;i<t.length;i++)t[i].x<e&&(e=t[i].x),t[i].x>r&&(r=t[i].x),t[i].y<o&&(o=t[i].y),t[i].y>s&&(s=t[i].y);return{[h.TOP_LEFT]:new i(e,o),[h.TOP_RIGHT]:new i(r,o),[h.BOTTOM_RIGHT]:new i(r,s),[h.BOTTOM_LEFT]:new i(e,s)}},p=t=>c(u()(t,(t=>t.getPoints())));class O{constructor(t=[]){this.points=t}serialize(){return a()(this.points,(t=>[t.x,t.y]))}deserialize(t){this.points=a()(t,(t=>new i(t[0],t[1])))}scale(t,e,i){let o=r.createScaleMatrix(t,e,i);s()(this.points,(t=>{t.transform(o)}))}transform(t){s()(this.points,(e=>{e.transform(t)}))}setPoints(t){this.points=t}getPoints(){return this.points}rotate(t){this.transform(r.createRotateMatrix(t/(180/Math.PI),this.getOrigin()))}translate(t,e){s()(this.points,(r=>{r.translate(t,e)}))}doClone(t){this.points=a()(t.points,(t=>t.clone()))}clone(){let t=Object.create(this);return t.doClone(this),t}getOrigin(){if(0===this.points.length)return null;let t=c(this.points);return i.middlePoint(t[h.TOP_LEFT],t[h.BOTTOM_RIGHT])}getBoundingBox(){return c(this.points)}}class d extends O{static fromPositionAndSize(t,e,r,i){return new d(l(t,e,r,i))}static fromPointAndSize(t,e,r){return new d(l(t.x,t.y,e,r))}constructor(t){t||(t=g()),super([t[h.TOP_LEFT],t[h.TOP_RIGHT],t[h.BOTTOM_RIGHT],t[h.BOTTOM_LEFT]])}updateDimensions(t,e,r,i){const o=l(t,e,r,i);this.setPoints([o[h.TOP_LEFT],o[h.TOP_RIGHT],o[h.BOTTOM_RIGHT],o[h.BOTTOM_LEFT]])}setPoints(t){if(4!==t.length)throw"Rectangles must always have 4 points";super.setPoints(t)}containsPoint(t){const e=this.getTopLeft(),r=this.getBottomRight();return t.x>=e.x&&t.x<=r.x&&t.y>=e.y&&t.y<=r.y}getWidth(){return Math.sqrt(Math.pow(this.getTopLeft().x-this.getTopRight().x,2)+Math.pow(this.getTopLeft().y-this.getTopRight().y,2))}getHeight(){return Math.sqrt(Math.pow(this.getBottomLeft().x-this.getTopLeft().x,2)+Math.pow(this.getBottomLeft().y-this.getTopLeft().y,2))}getTopMiddle(){return i.middlePoint(this.getTopLeft(),this.getTopRight())}getBottomMiddle(){return i.middlePoint(this.getBottomLeft(),this.getBottomRight())}getLeftMiddle(){return i.middlePoint(this.getBottomLeft(),this.getTopLeft())}getRightMiddle(){return i.middlePoint(this.getBottomRight(),this.getTopRight())}getTopLeft(){return this.points[0]}getTopRight(){return this.points[1]}getBottomRight(){return this.points[2]}getBottomLeft(){return this.points[3]}}var m;!function(t){t[t.SOURCE=0]="SOURCE",t[t.SOURCE_CONTROL=1]="SOURCE_CONTROL",t[t.TARGET_CONTROL=2]="TARGET_CONTROL",t[t.TARGET=3]="TARGET"}(m||(m={}));class x extends O{constructor(){super([new i(0,0),new i(0,0),new i(0,0),new i(0,0)])}getSVGCurve(){return`M${this.getSource().toSVG()} C${this.getSourceControl().toSVG()}, ${this.getTargetControl().toSVG()}, ${this.getTarget().toSVG()}`}setPoints(t){if(4!==t.length)throw new Error("BezierCurve must have extactly 4 points");super.setPoints(t)}getSource(){return this.points[m.SOURCE]}getSourceControl(){return this.points[m.SOURCE_CONTROL]}getTargetControl(){return this.points[m.TARGET_CONTROL]}getTarget(){return this.points[m.TARGET]}setSource(t){this.points[m.SOURCE]=t}setSourceControl(t){this.points[m.SOURCE_CONTROL]=t}setTargetControl(t){this.points[m.TARGET_CONTROL]=t}setTarget(t){this.points[m.TARGET]=t}}return e})()));
//# sourceMappingURL=index.umd.js.map